[["importation.html", "Chapter 4 Importation 4.1 Données de Parcoursup", " Chapter 4 Importation 4.1 Données de Parcoursup Les données de ParcourSup viennent de là : Parcoursup 2023 - vœux de poursuite d’études et de réorientation dans l’enseignement supérieur et réponses des établissements sinon vous avez les métiers en tensions : Taux de pression et d’emploi pour les diplômes de la voie professionnelle En suivant les liens vous pouvez télécharger les fichiers Excel. Déplacer le fichier Excel à la racine de votre projet. puis library(readxl) parcours &lt;- read_excel(&quot;data/fr-esr-parcoursup.xlsx&quot;) ## New names: ## • `Filière de formation` -&gt; `Filière de formation...10` ## • `Filière de formation` -&gt; `Filière de formation...14` Je viens de créer une data.frame du nom de parcours avec le contenu du fichier Excel. Pour sélectionner les variables, utiliser le raccourci TAB. Pour charger un fichier SPSS, il faut aussi un paquet supplémentaire : require(haven) patient &lt;- read_sav(&quot;data/patient.sav&quot;) C’est le même paquet pour les formats SAS (sas7bdat) et STATA. On trouve le chargement des mêmes types de fichier dans le paquet foreign mais attention ce sont pour les vieux formats de fichiers. Par exemple pour SAS, il suffit de changer de fonction : patient &lt;- read_sas(&quot;patient.sas7bdat&quot;) Lors de l’import, de SAS, SPSS, il conserve le type de la variable. Quand on veux importer un fichier Excel ou un fichier texte, cela est différent. On va prendre l’exemple de fichier texte : l’importation se fait en fait en trois temps. library(readr) patient &lt;- read_csv(&quot;data/patient.csv&quot;) ## Rows: 200 Columns: 17 ## ── Column specification ──────────────────────────────────────────────────────── ## Delimiter: &quot;,&quot; ## chr (5): UID, Hopital, sexe, scoliose, drepano ## dbl (12): poids, vitaux, CIM2, age, dureeopmin, postopj, ACP, peridurale, pe... ## ## ℹ Use `spec()` to retrieve the full column specification for this data. ## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. table(patient$scoliose) ## ## ante autre post ## 3 2 20 Dans un premier temps, la fonction read_csv va parcourir les 1000 premières lignes du fichier à la découverte de : - du séparateur entre les champs - du séparateur de décimales - le type de chaque colonne. Si par exemple il trouve que des chiffres dans une colonne, le type sera dbl. Par contre s’il trouve un mélange de charactères et de chiffres, là rien ne va plus. Ca peut se produire par exemple lorsque vous avez des chiffres mélangés à des valeurs manquantes qui sont représentés par des valeurs textes ou bien des symboles textuels. Les petites machines qui transforment les données en données typées sont des parser. Elles sont d’ailleurs disponible à part : str(parse_double(c(&quot;1.56&quot;, &quot;NA&quot;, &quot;NA&quot;))) ## num [1:3] 1.56 NA NA NA est reconnu comme valeur manquante alors pas de souci, le 1.56 est reconnu. et si on mettait 1,56 ? str(parse_double(c(&quot;1,56&quot;, &quot;NA&quot;, &quot;NA&quot;))) ## Warning: 1 parsing failure. ## row col expected actual ## 1 -- no trailing characters 1,56 ## num [1:3] NA NA NA ## - attr(*, &quot;problems&quot;)= tibble [1 × 4] (S3: tbl_df/tbl/data.frame) ## ..$ row : int 1 ## ..$ col : int NA ## ..$ expected: chr &quot;no trailing characters&quot; ## ..$ actual : chr &quot;1,56&quot; pas terrible ce qui suit : str(parse_double(c(&quot;1.56&quot;, &quot;NR&quot;, &quot;NR&quot;))) ## Warning: 2 parsing failures. ## row col expected actual ## 2 -- a double NR ## 3 -- a double NR ## num [1:3] 1.56 NA NA ## - attr(*, &quot;problems&quot;)= tibble [2 × 4] (S3: tbl_df/tbl/data.frame) ## ..$ row : int [1:2] 2 3 ## ..$ col : int [1:2] NA NA ## ..$ expected: chr [1:2] &quot;a double&quot; &quot;a double&quot; ## ..$ actual : chr [1:2] &quot;NR&quot; &quot;NR&quot; On rétablit la situation normale en mettant na = NR : str(parse_double(c(&quot;1.56&quot;, &quot;NA&quot;, &quot;NA&quot;),na = &quot;NR&quot;)) ## Warning: 2 parsing failures. ## row col expected actual ## 2 -- a double -- ## 3 -- a double -- ## num [1:3] 1.56 NA NA ## - attr(*, &quot;problems&quot;)= tibble [2 × 4] (S3: tbl_df/tbl/data.frame) ## ..$ row : int [1:2] 2 3 ## ..$ col : int [1:2] NA NA ## ..$ expected: chr [1:2] &quot;a double&quot; &quot;a double&quot; ## ..$ actual : chr [1:2] &quot;NA&quot; &quot;NA&quot; Dans la jungle des parsers, on a les parsers : - parse_logical() - parse_integer() - parse_double() - parse_character() - parse_number() - parse_factor() - parse_datetime() (may be the force with you) - … Si vous avez bien suivi, la machine va lire les n premières lignes et à chaque colonne essayer de deviner le type de variable et appeler le parser qui va bien : ce sont les fonctions guess_. Ceux sont eux qui vont décider du type de variable que vous importez. Pour le faire vous même, il suffit de spécificier chaque à la main : read_csv(&quot;data/iris.csv&quot;, col_types = list( Sepal.Length = col_double(), Sepal.Width = col_double(), Petal.Length = col_double(), Petal.Width = col_double(), Species = col_factor(c(&quot;setosa&quot;, &quot;versicolor&quot;, &quot;virginica&quot;)) )) Sur cette ligne, c’est un peu complexe et surtout cela fait appel à deux élements que vous connaissez pas. Les lists et les factors. Un factor est un ensemble de valeurs fini : c’est comme ça que vous pouvez coder un ensemble de valeurs que vous pouvez énumérer et que vous utiliseriez par exemple dans une expérience. Par exemple, on peut avoir comme facteur : le nombre de cylindres de mtcars 4, 6 ou 8 les médicaments dans une expérience en double aveugle: A, B, C … L’idée est qu’un facteur est à utiliser dans une ANOVA (un test de différences de moyennes sur 1 à k groupes). La liste est une data.frame libertaire : par libértaire j’entends qu’on peut mettre n’importe objet et l’indexer (presque) comme une data.frame. a &lt;- list(iris,c(1,2,3),LETTERS,mtcars[,c(&quot;cyl&quot;,&quot;mpg&quot;)]) str(a) ## List of 4 ## $ :&#39;data.frame&#39;: 150 obs. of 5 variables: ## ..$ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## ..$ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## ..$ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## ..$ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## ..$ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ : num [1:3] 1 2 3 ## $ : chr [1:26] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... ## $ :&#39;data.frame&#39;: 32 obs. of 2 variables: ## ..$ cyl: num [1:32] 6 6 4 6 8 6 8 4 4 6 ... ## ..$ mpg: num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... On voit que c’est un type list, les data.frame. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
